class Life{constructor(columns,rows,rulesString=null){this.columns=columns;this.rows=rows;this.cells={};this.living=0;this.livingStart=0;this.livingMax=0;this.livingMaxGen=0;this.generation=0;this._rulesString=null;this._rules=null;this._rulesFunc=null;this.setRules(rulesString||'B3/S23');}cellsArray(){let cells=[];let x,y;for(y in this.cells){for(x in this.cells[y]){cells.push([parseInt(x),parseInt(y)])}}return cells}clear(resetGen=false){this.cells={};this.living=0;if(resetGen){this.generation=0;this.livingStart=0;this.livingMax=0;this.livingMaxGen=0}}killCell(x,y){delete this.cells[y][x];this.living-=1}nextGeneration(){const columns=this.columns;const rows=this.rows;const nextGen={};let x,xx,y,yy,n;for(y in this.cells){y=parseInt(y);if(!(y in nextGen)){nextGen[y]={}}for(x in this.cells[y]){x=parseInt(x);if(!(x in nextGen[y])){nextGen[y][x]={'alive':true,'neighbours':0}}else{nextGen[y][x]['alive']=true}for(yy=y-1;yy<y+2;yy+=1){for(xx=x-1;xx<x+2;xx+=1){if((yy!=y)||(xx!=x)){if(!(yy in nextGen)){nextGen[yy]={}}if(!(xx in nextGen[yy])){nextGen[yy][xx]={'alive':false,'neighbours':1}}else{nextGen[yy][xx]['neighbours']+=1}}}}}}this.clear();for(y in nextGen){for(x in nextGen[y]){n=nextGen[y][x]['neighbours'];if(this._rulesFunc(nextGen[y][x])){this.setCell(x,y,n)}}}this.generation+=1;this.updateLivingData()}rleString(){const cells=this.cells;const minCol=cellsMinCol(cells);const maxCol=cellsMaxCol(cells);const minRow=cellsMinRow(cells);const maxRow=cellsMaxRow(cells);let xKeys=null;let yKeys=Object.keys(cells).sort(compareKeys);let i,x,lx,y,ly,n,xDiff,yDiff;let RLEString='';x=(maxCol-minCol);if(x>0){x+=1}y=(maxRow-minRow);if(y>0){y+=1}RLEString+=`#R ${ minCol } ${ minRow }\n`;RLEString+=`x = ${ x }, y = ${ y }, `;RLEString+=`rule = ${this._rulesString }\n`;if(yKeys.length<1){return RLEString}ly=yKeys[0];for(y of yKeys){xKeys=Object.keys(cells[y]).sort(compareKeys);xDiff=xKeys[0]-minCol;yDiff=y-ly;if(yDiff>1){RLEString+=(yDiff+'$')}else if(yDiff==1){RLEString+='$'}if(xDiff>1){RLEString+=xDiff.toString()+'b'}else if(xDiff==1){RLEString+='b'}i=0,n=0,lx=xKeys[0];while(i<xKeys.length){x=xKeys[i];xDiff=(x-lx);if(xDiff==1){n+=1}else{if(n>1){RLEString+=n.toString()+'o'}else if(n==1){RLEString+='o'}if(xDiff>2){RLEString+=(xDiff-1).toString()+'b'}else if(xDiff>1){RLEString+='b'}n=1}lx=x;i+=1}if(n>1){RLEString+=n.toString()+'o'}else{RLEString+='o'}ly=y}return wrapRLE(RLEString+='!',70)}readRLEString(RLEString){let cells=this.cells;let x,xs,y,ys,i,ii,c,lc,num,shiftX,shiftY;let ignore=[' ','\n'];let patternStart=RLEString.search(/^((\d*[ob])+\$*)/im);let patternShift=RLEString.match(/#R\s+(-*\d+)\s+(-*\d+)/im);if(patternShift){shiftX=parseInt(RegExp.$1||'0');shiftY=parseInt(RegExp.$2||'0')}else{shiftX=0;shiftY=0}let rule=RLEString.match(/rule\s*=\s*(B\d*\/S\d*)/im);if(rule){this.setRules(RegExp.$1)}x=0,y=0,i=patternStart;this.clear(true);while(i<RLEString.length){c=RLEString[i];if(c=='#'){while(c!='\n'){c=RLEString[i+=1]}}else if(!ignore.includes(c)){xs=x+shiftX;ys=y+shiftY;num='';while(!isNaN(parseInt(c))){num+=c;c=RLEString[i+=1]}if(c=='o'){if(num){for(ii=0;ii<parseInt(num);ii+=1){this.setCell(xs++,ys);x+=1}}else{this.setCell(xs,ys);x+=1}}else if(c=='b'){if(num){x+=parseInt(num)}else{x+=1}}else if(c=='$'){if(num){y+=parseInt(num)}else{y+=1}x=0}}i+=1}if(c=='o'){if(num){for(i=0;i<parseInt(num);i+=1){this.setCell(x++,y)}}else{this.setCell(x,y)}}this.updateLivingData()}setCell(x,y,neighbours=0){if(!(y in this.cells)){this.cells[y]={}}if(!(x in this.cells[y])){this.living+=1}this.cells[y][x]={'alive':true,'neighbours':neighbours}}setCells(cells,clear=true){let x,y;if(clear){this.clear(true)}for(y in cells){for(x in cells[y]){this.setCell(x,y)}}}setCellsArray(cells,clear=true){let i,coords;let cellsCopy=cells.slice(0);if(clear){this.clear(true);this.livingStart=cells.length}while(coords=cellsCopy.shift()){this.setCell(...coords)}}setRules(rulesString){this._rulesString=rulesString.trim();this._rules=parseRulesString(this._rulesString);this._rulesFunc=newRules(this._rulesString)}setRulesFunction(func){this._isLiving=func}updateLivingData(){if(!this.generation){this.livingStart=this.living}if(this.living>this.livingMax){this.livingMax=this.living;this.livingMaxGen=this.generation}}}function parseRulesString(rules){let born=null,survive=null;rules.match(/(?:B)(\d+|\b)(?:\/)(?:S)(\d+|\b)/i);if(RegExp.$1==null||RegExp.$2==null){return false}born=Array.from(RegExp.$1).map(b=>parseInt(b));survive=Array.from(RegExp.$2).map(s=>parseInt(s));return{born,survive}}function newRules(rulesString){let{born,survive}=parseRulesString(rulesString);return function(cell){let{alive,neighbours}=cell;return((alive&&survive.includes(neighbours))||(!alive&&born.includes(neighbours)))}}function newRules2(rulesString){let{born,survive}=parseRulesString(rulesString);if(born.includes(0)){if(survive.includes(8)){return function(cell){let{alive,neighbours}=cell;return((alive&&survive.includes(neighbours))||(!alive&&born.includes(neighbours)))}}}else{return function(cell){let{alive,neighbours}=cell;return((alive&&survive.includes(neighbours))||(!alive&&born.includes(neighbours)))}}}function convertB0Rule(rulesString){return}function arrayMaxCol(pattern){return pattern.reduce((previous,coords)=>{if(coords[0]>previous[0]){return coords}return previous})[0]}function arrayMinCol(pattern){return pattern.reduce((previous,coords)=>{if(coords[0]<previous[0]){return coords}return previous})[0]}function arrayMaxRow(pattern){return pattern.reduce((previous,coords)=>{if(coords[1]>previous[1]){return coords}return previous})[1]}function arrayMinRow(pattern){return pattern.reduce((previous,coords)=>{if(coords[1]<previous[1]){return coords}return previous})[0]}function cellsMinRow(cells){let cellsKeys=Object.keys(cells);if(cellsKeys.length==0){return 0}return Math.min(...cellsKeys)}function cellsMaxRow(cells){let cellsKeys=Object.keys(cells);if(cellsKeys.length==0){return 0}return Math.max(...cellsKeys)}function cellsMinCol(cells){let cellsKeys=Object.keys(cells);let y,temp,min=-1;if(cellsKeys.length==0){return 0}for(y of cellsKeys){temp=Math.min(...Object.keys(cells[y]));if((min==-1)||(temp<min)){min=temp}}return min}function cellsMaxCol(cells){let cellsKeys=Object.keys(cells);let y,temp,max=-1;if(cellsKeys.length==0){return 0}for(y of cellsKeys){temp=Math.max(...Object.keys(cells[y]));if((max==-1)||(temp>max)){max=temp}}return max}function shiftPattern(pattern,x,y){let cells={};let xx,yy,yMod;for(yy in pattern){yMod=yy+y;if(!(yMod in cells)){cells[yMod]={}}for(xx in pattern){cells[yMod][xx+x]=pattern[yy][xx]}}return cells}function shiftPatternArray(pattern,x,y){for(let i=0;i<pattern.length;i+=1){pattern[i][0]+=x;pattern[i][1]+=y}return pattern}function centerPattern(pattern,columns,rows){const patternColsHalf=Math.floor(cellsMaxCol(pattern)/2)+1;const patternRowsHalf=Math.floor(cellsMaxRow(pattern)/2);const colsHalf=Math.floor(columns/2);const rowsHalf=Math.floor(rows/2);return shiftPatternArray(pattern,(colsHalf-patternColsHalf),(rowsHalf-patternRowsHalf))}function centerPatternArray(pattern,columns,rows){const patternColsHalf=Math.floor(arrayMaxCol(pattern)/2)+1;const patternRowsHalf=Math.floor(arrayMaxRow(pattern)/2);const colsHalf=Math.floor(columns/2);const rowsHalf=Math.floor(rows/2);return shiftPatternArray(pattern,(colsHalf-patternColsHalf),(rowsHalf-patternRowsHalf))}function compareKeys(a,b){a=parseInt(a);b=parseInt(b);if(a<b){return -1}if(a>b){return 1}return 0}function wrapRLE(RLEString,width){let newText='';let c,lc,i,j,w=0;let widthMod=width-1;let RLELength=RLEString.length;i=RLEString.search(/\n((\d*[ob])+\$*)/im)+1;j=i;newText+=RLEString.slice(0,i);while(i<RLELength){while((i<RLELength)&&(w<width-2)){i+=1;w+=1}while(!isNaN(parseInt(RLEString[i]))){i-=1}i+=1;newText+=RLEString.slice(j,i)+'\n';j=i;w=0}return newText}
